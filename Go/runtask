To update the `rotateHandler` in `server.go` so that it outputs the response from the execution of the `RunTask` function, you need to capture the output generated by `RunTask`. Here’s an approach you could take:

1. Modify the `RunTask` function to return a string with logs or messages generated during its execution.
2. Update the `rotateHandler` to write the output of `RunTask` back to the HTTP response.

Here’s how to do that in detail:

### Step 1: Modify `RunTask` to return a string

Update the `RunTask` function to build a response string based on its execution. You can use a `strings.Builder` for this:

```go
package rotator

import (
	"fmt"
	"strings"
	"time"
	"go.uber.org/zap"
)

// Update RunTask to return log messages
func RunTask(logger *zap.Logger, conf *rotator.Config) (string, error) {
	var responseBuilder strings.Builder

	runtimeEvaCertLoginToken, err := CertLogin(conf.RuntimeCert, conf.RuntimeKey, conf.Namespace, conf.EvaVaultUrl)
	if err != nil {
		return "", fmt.Errorf("error in logging into Eva using Runtime Eva Certificate: %w", err)
	}

	deployEvaCertLoginToken, err := CertLogin(conf.DeployCert, conf.DeployKey, conf.Namespace, conf.EvaVaultUrl)
	if err != nil {
		return "", fmt.Errorf("error in logging into Eva using Deploy Eva Certificate: %w", err)
	}

	svcDeployAccount, err := EvaGetSvcAccount(deployEvaCertLoginToken, conf.Namespace, conf.EvaVaultUrl, conf.DeploySvcAccount)
	if err != nil {
		return "", fmt.Errorf("error getting svc runtime credentials: %w", err)
	}
	evaDeployApiLoginToken, err := EvaApiLogin(svcDeployAccount.ClientId, svcDeployAccount.Secret, azTenantID, evaApiURL)
	if err != nil {
		return "", fmt.Errorf("error logging into eva API using svc credentials: %w", err)
	}

	// Iterate through Secrets
	for _, user := range conf.SecretsToRotate {
		parts := strings.Split(user, ",")
		if len(parts) != 4 {
			responseBuilder.WriteString(fmt.Sprintf("failed to unmarshal response: %s\n", user))
			continue
		}
		uType := parts[0]
		uPath := parts[1]
		uName := parts[2]
		uDomain := parts[3]

		fullVaultURL := conf.EvaVaultUrl + "/secret/data/" + uType + "/" + uPath + "/" + uName
		fullApiURL := "https://" + evaApiUrl + ":8250/password/" + uDomain + "/" + conf.Namespace + "/" + uName
		
		var rotationDate time.Duration
		var rotateToken string
		var version int
		
		// Getting the rotation dates/logics
		switch uType {
		case "runtime":
			rotationDate, version, err = GetRotationDate(runtimeEvaCertLoginToken, conf.Namespace, fullVaultURL)
			rotateToken = evaDeployApiLoginToken
		case "deploy":
			rotationDate, version, err = GetRotationDate(deployEvaCertLoginToken, conf.Namespace, fullVaultURL)
			rotateToken = evaDeployApiLoginToken
		default:
			logger.Error("Invalid user type should be 'runtime' or 'deploy'", zap.String("type", uType))
			return "", nil
		}
		
		if err != nil {
			responseBuilder.WriteString(fmt.Sprintf("error getting password rotation date from EVA: %v\n", err))
			continue
		}
				
		// Check if rotation is needed
		if rotationDate < 11*30*24*time.Hour || version == 1 {
			rotateUser, err := ApiRotate(rotateToken, fullApiURL)
			if err != nil {
				responseBuilder.WriteString(fmt.Sprintf("error rotating user %s: %v\n", uName, err))
			} else {
				responseBuilder.WriteString(fmt.Sprintf("Account %s rotated successfully: %s\n", uName, rotateUser))
			}
		} else {
			responseBuilder.WriteString(fmt.Sprintf("No password rotation needed for account %s.\n", uName))
		}
	}
	
	return responseBuilder.String(), nil
}
```

### Step 2: Update the `rotateHandler`

Now update the `rotateHandler` in `server.go` to capture the response and write it to the HTTP response:

```go
package rest

import (
	"net/http"
	"fmt"
	"os"
	"encoding/json"
	"configs"
	"go.uber.org/zap"
	"rotator"
	"io"
)

const Port = 8080

type RotateRequest struct {
	Secret []string `json:"Secret"`
}

// New creates a new Server instance with the provided logger and config loader.
func New(logger *zap.Logger, configLoader *ConfigLoader) *Server {
	return &Server{
		logger:       logger,
		configLoader: configLoader,
	}
}

// Start initializes and starts the HTTP server with the necessary handlers.
func (s *Server) Start() error {
	mux := http.NewServeMux()

	// ... other handlers ...

	rotateHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "invalid request method", http.StatusMethodNotAllowed)
			return
		}
		var rotateRequest RotateRequest
		if err := json.NewDecoder(r.Body).Decode(&rotateRequest); err != nil {
			s.logger.Error("Failed to decode request body", zap.Error(err))
			http.Error(w, "Failed to decode request", http.StatusBadRequest)
			return
		}

		var conf rotator.Config
		if err := s.configLoader.DecodeSection("", &conf); err != nil {
			s.logger.Error("cannot load config", zap.Error(err))
			http.Error(w, "cannot load config", http.StatusInternalServerError)
			return
		}

		conf.SecretsToRotate = rotateRequest.Secret

		// Call RunTask and capture its output
		result, err := rotator.RunTask(s.logger, &conf)
		if err != nil {
			s.logger.Error("Error running rotate task", zap.Error(err))
			http.Error(w, fmt.Sprintf("Error running rotate task: %v", err), http.StatusInternalServerError)
			return
		}

		// Write the output of RunTask to the response
		w.WriteHeader(http.StatusOK)
		_, _ = io.WriteString(w, result)
	})

	mux.Handle("/rotate", rotateHandler)

	// ... other handlers ...

	err := http.ListenAndServe(fmt.Sprintf(":%d", Port), mux)
	if err != nil {
		return err
	}
	return nil
}
```

### Summary

With these modifications, the `RunTask` function now returns a string containing generated log messages, which will be sent back as the response when a client requests the `/rotate` endpoint. This change allows you to easily see what actions were taken inside the rotation logic without needing to access logs separately.
